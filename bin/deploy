#!/usr/bin/env bash

set -e -o pipefail -u

# =============================================================================
# CONSTANTS
# For convenience.
# =============================================================================

TRUE="t"
FALSE="f"

# =============================================================================
# CLI OPTION DEFAULT VALUES
# These represent the default state of the script.
# =============================================================================

opt_dry_run="$TRUE"
opt_verbose="$FALSE"

# =============================================================================
# HELPER FUNCTIONS
# Separated for convenience.
# =============================================================================

red() {
  echo -e "\033[0;31m$1\033[0m"
}

blue() {
  echo -e "\033[0;34m$1\033[0m"
}

verbose() {
  if [[ "$opt_dry_run" = "$TRUE" || "$opt_verbose" = "$TRUE" ]]; then
    echo "$1" > /dev/tty
  fi
}

perform() {
  if [ "$opt_dry_run" = "$FALSE" ]; then
    "$@"
  fi
}

error() {
  cat <<< "$(red "ERROR:") $@" >&2
  exit 1
}

# =============================================================================
# FILE ACTIONS
# Each should contain a "dry run" and "regular" version of the actions so we
# can test what will happen prior to execution.
# =============================================================================

create_dir() {
  verbose "mkdir $(blue "$1")"
  perform "mkdir $1"
}

deprecate_file() {
  verbose "mv $(blue "$1") -> $(blue "$1.replaced")"
  perform "mv $1 $1.replaced 2> /dev/null"
}

symlink_file() {
  local proj_file="$1"
  local home_file="$2"
  verbose "ln $(blue "$home_file") -> $(blue "$proj_file")"
  perform "ln -fs $proj_file $home_file"
}

# =============================================================================
# DEPLOYMENT PROCEDURE
# These should never call file actions suchs "mv" or "mkdir" directly but
# reference the above FILE ACTIONS.
# =============================================================================

deploy_file() {
  local proj_file="$1"
  local home_file="$2"

  [[ ! -h "$home_file" ]] && deprecate_file "$home_file"
  symlink_file "$proj_file" "$home_file"
}

deploy_dir() {
  local proj_dir="$1"
  local home_dir="$2"

  if [[ -e "$home_dir" && ! -d "$home_dir" ]]; then
    error "$(blue "$home_dir") already exists."
  fi

  if [ ! -e "$home_dir" ]; then
    create_dir "$home_dir"
  fi

  deploy_all_in "$proj_dir" "$home_dir" ""
}

deploy_all_in() {
  local proj_dir="$1"
  local home_dir="$2"
  local prefix="$3"

  for file in $proj_dir/*; do
    local path_seg="${file##*/}"

    if [ -d "$file" ]; then
      deploy_dir "$file" "$home_dir/$prefix$path_seg"
    else
      deploy_file "$file" "$home_dir/$prefix$path_seg"
    fi
  done
}

# =============================================================================
# MAIN
# The actual program.
# =============================================================================

parse_options() {
  while [[ $# -gt 0 ]]; do
    case $1 in
      -d|--dry-run) opt_dry_run="$TRUE"; shift ;;
      -v|--verbose) opt_verbose="$TRUE"; shift ;;
      *) error "Unknown argument \"$1\"" ;;
    esac
  done
}

main() {
  rel_path="$(dirname "$0")"
  cd "$rel_path/.."
  deploy_all_in "$(pwd)/home" "$HOME" "."
}

parse_options $@
main
